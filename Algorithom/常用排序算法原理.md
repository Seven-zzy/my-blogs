###　常用排序算法及其稳定性
#### 稳定：
冒泡排序、插入排序、归并排序、基数排序
#### 不稳定：
选择排序、希尔排序、快速排序、堆排序

### 常用排序算法分类
#### 比较排序：
冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序
#### 非比较排序：基数排序、计数排序、桶排序

### 约定所有排序要求结果为升序，即从小到大排列。

### 冒泡排序
算法步骤：
1. 比较两相邻元素的大小，若前面的元素大于后面的元素，则交换位置。一轮比较下来，最大的元素会出现在数组末尾。
2. 重复步骤1，直至没有任何一对元素需要比较。

// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定

### 选择排序
选择排序基于冒泡排序做了优化。冒泡排序是依次比较相邻2元素的大小并交换，选择排序每轮遍历选取一个最小元素，仅进行一次交换即可。
算法原理：
选择排序是每次选取未排序序列最小的元素，放到序列起始位置作为已排序序列。再依次选取未排序序列的最小元素，放在已排序序列的队尾。

// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- O(n^2)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定

### 插入排序
算法原理：
插入排序类似抓扑克牌，右手拿到牌后，与左手（已排序序列）中的牌从后向前比较，若左手当前牌大于右手牌，则左手牌右移一位。直至左手牌小于等于右手牌，插入该位置的右边，
算法步骤：
1. 第一个元素就作为已排序序列（类似左手已经拿到的牌）。
2. 从第二个元素开始，作为比较对象，将已排序序列的元素从后向前，作为目标位置，与比较对象比较，若目标位置
元素大于比较对象，则将目标位置后移一位。
3. 重复步骤2，直至找到目标位置元素小于等于比较对象，将比较对象插入目标位置的右侧。
3. 比较对象后移，重复步骤2、3。

// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定

### 希尔排序
算法原理：
改进了插入排序。希尔排序将待排序序列分成几个区域来提高插入排序的性能，这样可以让一个元素一次移动一大步。再逐渐缩小步长，最后就是普通的插入排序。这样最后插入排序的数据就是已经基本排好序了，此时插入排序效率最高。

// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)
// 最优时间复杂度 ---- O(n)
// 平均时间复杂度 ---- 根据步长序列的不同而不同。
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定

### 快速排序
算法原理：
分治的思想。递归调用
1. 取序列中一个元素作为基准pivot。
2. 使所有比基准小的值位于基准左边，所有比基准大的值位于基准右边。
3. 分别对左右两边递归进行步骤1、2，递归结束条件为序列大小为0或1。

// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)
// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)
// 平均时间复杂度 ---- O(nlogn)
// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       
// 稳定性 ---------- 不稳定

### 堆排序
借助堆这个数据结构进行排序。例如大顶堆。递归调用。

1. 将初始无序序列生成一个大顶堆。
2. 把大顶堆的堆顶元素（最大值）与堆尾元素交换。
3. 将堆（无序序列）的尺寸缩小1，再次选出新的堆顶元素。
4. 重复步骤2，直到堆的尺寸为1。

// 最差时间复杂度 ---- O(nlogn)
// 最优时间复杂度 ---- O(nlogn)
// 平均时间复杂度 ---- O(nlogn)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定

### 归并排序
主要依赖归并操作，指将2个已经排序的序列合并成一个序列。
1. 申请空间，空间大小为2个已排序序列的空间之和，用来存放合并后的序列
2. 设定2个指针，分别指向2个序列的起始位置。
3. 选取2个指针中最小的一个放入合并空间，并移动指针到下一位置。
4. 重复步骤3，直至有一个序列到达序列尾。
5. 将剩下一个序列的剩余全部元素放到合并后序列末尾。
当待排序的序列长度为1时，递归开始回溯，进行merge操作

// 最差时间复杂度 ---- O(nlogn)
// 最优时间复杂度 ---- O(nlogn)
// 平均时间复杂度 ---- O(nlogn)
// 所需辅助空间 ------ O(n)
// 稳定性 ------------ 稳定
